import path from 'path';
import fs from 'fs';
import { LabPatrol } from './part-2';
import { convertLayoutToArray } from '../helpers';

let patrol: LabPatrol;

beforeEach(() => {
  const filePath = path.resolve(__dirname, '../test-input.txt');
  const data = fs.readFileSync(filePath, 'utf-8');

  const layoutArray = convertLayoutToArray(data);

  patrol = new LabPatrol(layoutArray);
});

describe('day-6 Pt.2', () => {
  describe('Getting guard position', () => {
    test('should get coordinate {col: 4, row: 6} for the guard position', () => {
      const layout = `....#.....
      .........#
      ..........
      ..#.......
      .......#..
      ..........
      .#..^.....
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.getPosition(layoutArray, '^')).toEqual({ col: 4, row: 6 });
    });
    test('should get coordinate {col: 9, row: 3} for the guard position', () => {
      const layout = `....#.....
        .........#
        ..........
        ..#......^
        .......#..
        ..........
        .#........
        ........#.
        #.........
        ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.getPosition(layoutArray, '^')).toEqual({ col: 9, row: 3 });
    });
  });
  describe('Checking for obstructions', () => {
    test('should return false when there is no obstruction ahead', () => {
      const layout = `....#.....
        .........#
        ..........
        ..#.......
        .......#..
        ..........
        .#..^.....
        ........#.
        #.........
        ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.checkObstructionAhead(layoutArray)).toBe(false);
    });
    test('should return true where there is a # obstruction ahead', () => {
      const layout = `....#.....
  ....^....#
  ..........
  ..#.......
  .......#..
  ..........
  .#........
  ........#.
  #.........
  ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.checkObstructionAhead(layoutArray)).toBe(true);
    });
    test('should return true where there is a `0` obstruction ahead', () => {
      const layout = `....O.....
  ....^....#
  ..........
  ..#.......
  .......#..
  ..........
  .#........
  ........#.
  #.........
  ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.checkObstructionAhead(layoutArray)).toBe(true);
    });
    test('should return false if the guard is no longer in the area', () => {
      const layout = `....#.....
  .........#
  ..........
  ..#.......
  .......#..
  ..........
  .#........
  ........#.
  #.........
  ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.checkObstructionAhead(layoutArray)).toBe(false);
    });
  });
  describe('Taking steps', () => {
    test('should take a step if there are no obstacles ahead', () => {
      const layout = `
        ...
        .^.
        ...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayout = `
        .^.
        ...
        ...`;
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.stepForward(layoutArray)).toStrictEqual(newLayoutArray);
    });
    test('should take a step out of the area if there are no obstacles ahead', () => {
      const layout = `....#.....
      .........#
      ..........
      ..#.......
      .......#..
      ........^.
      .#........
      ........#.
      #.........
      ......#...`;
      const newLayout = `....#.....
      .........#
      ..........
      ..#.......
      .......#^.
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.stepForward(layoutArray)).toStrictEqual(newLayoutArray);
    });
    test('should NOT take a step if there is an obstacle ahead', () => {
      const layout = `....#.....
      ....^....#
      ..........
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      expect(patrol.stepForward(layoutArray)).toStrictEqual(layoutArray);
    });
  });
  describe('Avoiding obstructions', () => {
    test('should turn right 90 degress and step foward to avoid the # obstruction', () => {
      const layout = `....#.....
      ....^....#
      ..........
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayout = `.#........
      .......#..
      ....#.....
      .........#
      .^........
      #.........
      ..........
      ...#......
      ......#...
      ........#.`;
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.avoidObstruction(layoutArray)).toStrictEqual(
        newLayoutArray
      );
    });
    test('should turn right 90 degress and step foward to avoid the O obstruction', () => {
      const layout = `....O.....
      ....^....#
      ..........
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayout = `.#........
      .......#..
      ....#.....
      .........#
      .^........
      O.........
      ..........
      ...#......
      ......#...
      ........#.`;
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.avoidObstruction(layoutArray)).toStrictEqual(
        newLayoutArray
      );
    });
  });
  describe('Updating the Layout after the guard moves', () => {
    test('should move the guard forward and add . when moving forward only', () => {
      const layout = `....#.....
      .........#
      ....^.....
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayout = `....#.....
      ....^....#
      ..........
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.updateLayout(layoutArray, 'forward')).toStrictEqual(
        newLayoutArray
      );
    });
    test('should move the guard forward and add + when avoiding and obstacle', () => {
      const layout = `....#.....
      .........#
      ....^.....
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const layoutArray = convertLayoutToArray(layout);
      const newLayout = `....#.....
      ....^....#
      ..........
      ..#.......
      .......#..
      ..........
      .#........
      ........#.
      #.........
      ......#...`;
      const newLayoutArray = convertLayoutToArray(newLayout);
      expect(patrol.updateLayout(layoutArray, 'avoid')).toStrictEqual(
        newLayoutArray
      );
    });
  });
  describe('Getting sum of different positions to add an obstruction', () => {
    test('should get the sum of position an obstruction can be added to trap the guard in a loop', () => {
      expect(patrol.getSumOfLoopOptions()).toBe(6);
    });
  });
});
